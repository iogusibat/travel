コードを書くとき、テーブル駆動方式は過小評価されています。非常に強力なテクニックなので、事例とそのインパクトを説明します。

## 概略サンプル

```
<span>if</span> age &lt; <span>10</span>:
    <span>return</span> price / <span>2</span>
<span>elif</span> age &lt; <span>20</span>:
    <span>return</span> price / <span>3</span>
<span>elif</span> age &lt; <span>50</span>:
    <span>return</span> price / <span>5</span>
<span>else</span>:
    <span>return</span> price / <span>100</span>
```

↓

```
age_table = [
    [<span>10</span>, <span>1.0</span>/<span>2</span>],
    [<span>20</span>, <span>1.0</span>/<span>3</span>], 
    [<span>50</span>, <span>1.0</span>/<span>5</span>],
    [<span>float</span>(<span>'inf'</span>),<span>1.0</span>/<span>100</span>] 
]

<span>for</span> target <span>in</span> age_table:
    <span>if</span> age &lt; target[<span>0</span>]:
        <span>return</span> price * target[<span>1</span>]
```

## メリット：ほぼどんな言語でも使える

いわゆるデシジョンテーブルです。パターンマッチがない言語でも大丈夫です。Unit Testで使うとテーブル駆動テストと呼ばれるようです。

## メリット：読みやすい

同じ構造なので驚きがありません。3パターン目が急に謎の処理をしないか不安になったことはありませんか？1行1行ドキドキしながら読む必要はなく、読み飛ばせます。IF文と違い、語彙が精緻といえます。

## メリット：変更に強い

データを増減させるなり修正するなりすればOKです。

## メリット：考えやすい

複雑な条件は表にするとわかりやすく整理できます。表で考えたり修正したほうが早いでしょう。テーブル駆動は表にしやすい...というより、表をそのままプログラム化したものです。

2次元テーブルの例を見比べてみましょう

| 条件1/2 | カレー | ステーキ | ラーメン |
| --- | --- | --- | --- |
| 100円 | レトルト | 危険 | カップラーメン |
| 1,000円 | いいね | 大丈夫？ | 普通 |
| 10,000円 | 宮廷料理？ | 満足 | 卒倒 |

```
decision = { 
    <span>100</span>:{<span>'カレー'</span>: <span>'レトルト'</span>,<span>'ステーキ'</span>:<span>'やばい'</span>,<span>'ラーメン'</span>:<span>'カップラーメン'</span>}
    <span>1000</span>:{<span>'カレー'</span>: <span>'いいね'</span>,<span>'ステーキ'</span>:<span>'怪しい'</span>,<span>'ラーメン'</span>:<span>'普通'</span>}
    <span>10000</span>:{<span>'カレー'</span>: <span>'卒倒'</span>,<span>'ステーキ'</span>:<span>'満足'</span>,<span>'ラーメン'</span>:<span>'卒倒'</span>}
}
<span>print</span>(decision[budget][menu]) 
```

テーブルを使えないかを考えるだけで、たとえ実際に使わなくてもロジックがスッキリします。

＊多くのプログラミング言語は第一級関数を持っており、配列等に入れた関数をapply/callといった形で呼び出すこともできます。

## メリット：外部化しやすい

データをjsonといった外部ファイルにできます。修正してもデプロイ不要に。Excelに入れるもDBに入れるも可能です。そうすればビジネスロジックの専門家が直接ロジックの更新できるようになります。

\=> ルールエンジンへ

## テーブル駆動方式が与えるインパクト

ビジネスロジックをコードからデータに変換できます。外部化してデータとして扱えば開発へのインパクトが大きくなります。

## テストが大幅に削減できます

ルールをロジックに転写できているかのテストが不要です。もちろんルール自体が誤っていないかは検証が必要です。

## デプロイ、リリースが削減できます

アプリケーションのデプロイからリリースはまだまだリスクが大きい組織が多いでしょう。リードタイムも長い傾向にあります。ロジックからデータに移行することで、素早く反映できます。

また、ロールバックする際、コードのロールバックなら1時間、インフラでの切り戻しなら10分かかります。データなら1分で反映可能です。

＊コード修正によるロールフォワードは半日かかり、さらに新しい障害が発生します。

## ビジネスユーザーが修正でき、調整が削減できます

データ化し、管理画面などを提供することで、圧倒的リードタイムで修正できます。エンジニアの工数も不要になりますね。

## 注意点

-   テーブルに存在しないパターンを必ず考慮する
-   同一構造が前提なので構造ごと変えたいときは弱い
-   テストはしやすいが、コンパイラによる支援は効きづらいことも
-   仕様自体の誤りからは逃れられないのでパラノイアだけが生き残る

## 最後に

> Code is a liability

ということで、なるべく価値あたりのコードベースを削減していきましょう。テーブル駆動方式はその一つの手段です。サーバレス化もそうですが、理解しやすさとユーザー価値を両立させましょう。

文責: 高木

[

![](%E3%83%86%E3%83%BC%E3%83%96%E3%83%AB%E9%A7%86%E5%8B%95%E6%96%B9%E5%BC%8F%E3%81%8C%E4%B8%8E%E3%81%88%E3%82%8B%E9%96%8B%E7%99%BA%E3%82%A4%E3%83%B3%E3%83%91%E3%82%AF%E3%83%88%20-%20KAKEHASHI%20Tech%20Blog/https%253A%252F%252Fcdn.blog.st-hatena.com%252Fimages%252Fcircle%252Fofficial-circle-icon%252Fcomputers.gif)

](https://blog.hatena.ne.jp/-/group/11696248318754550880/redirect?blog_id=26006613781264652)